/*
    Copyright (C) 2017 Luca De Feo

    This file is part of FLINT.

    FLINT is free software: you can redistribute it and/or modify it under
    the terms of the GNU Lesser General Public License (LGPL) as published
    by the Free Software Foundation; either version 2.1 of the License, or
    (at your option) any later version.  See <http://www.gnu.org/licenses/>.
*/

*******************************************************************************

    Computing isomorphisms and embeddings of finite fields

*******************************************************************************

void fq_embed_gens(fq_t gen_sub, fq_t gen_sup,
                   fmpz_mod_poly_t minpoly,
                   const fq_ctx_t sub_ctx, const fq_ctx_t sup_ctx)

    Given two contexts \code{sub_ctx} and \code{sup_ctx}, such that
    \code{degree(sub_ctx)} divides \code{degree(sup_ctx)}, compute:

    \begin{itemize}
    \item an element \code{gen_sub} in \code{sub_ctx} such that
      \code{gen_sub} generates the finite field defined by
      \code{sub_ctx},
    \item its minimal polynomial \code{minpoly},
    \item a root \code{gen_sup} of \code{minpoly} inside the field
      defined by \code{sup_ctx}.
    \end{itemize}
    
    These data uniquely define an embedding of \code{sub_ctx} into
    \code{sup_ctx}.

    
void _fq_embed_gens_naive(fq_t gen_sub, fq_t gen_sup,
                          fmpz_mod_poly_t minpoly,
                          const fq_ctx_t sub_ctx, const fq_ctx_t sup_ctx)

    Given two contexts \code{sub_ctx} and \code{sup_ctx}, such that
    \code{degree(sub_ctx)} divides \code{degree(sup_ctx)}, compute an
    embedding of \code{sub_ctx} into \code{sup_ctx} defined as follows:

    \begin{itemize}
    \item \code{gen_sub} is the canonical generator of \code{sup_ctx}
      (i.e., the class of $X$),
    \item \code{minpoly} is the defining polynomial of \code{sub_ctx},
    \item \code{gen_sup} is a root of \code{minpoly} inside the field
      defined by \code{sup_ctx}.
    \end{itemize}

void fq_embed_matrices(fmpz_mod_mat_t embed, fmpz_mod_mat_t project,
                       const fq_t gen_sub, const fq_ctx_t sub_ctx,
                       const fq_t gen_sup, const fq_ctx_t sup_ctx,
                       const fmpz_mod_poly_t gen_minpoly)

    Given:

    \begin{itemize}
    \item two contexts \code{sub_ctx} and \code{sup_ctx}, of
      respective degrees $m$ and $n$, such that $m$ divides $n$;
    \item a generator \code{gen_sub} of \code{sub_ctx}, its minimal
      polynomial \code{gen_minpoly}, and a root \code{gen_sup} of
      \code{gen_minpoly} in \code{sup_ctx}, as returned by
      \code{fq_embed_gens};
    \end{itemize}
    
    Compute:

    \begin{itemize}
    \item the $n\times m$ matrix \code{embed} mapping \code{gen_sub}
      to \code{gen_sup}, and all their powers accordingly;
    \item an $m\times n$ matrix \code{project} such that
      \code{project} $\times$ \code{embed} is the $m\times m$ identity
      matrix.
    \end{itemize}

void fq_trace_matrix(fmpz_mod_mat_t res, const fmpz_mod_mat_t basis,
                     const fq_ctx_t sub_ctx, const fq_ctx_t sup_ctx)

    Given:

    \begin{itemize}
    \item two contexts \code{sub_ctx} and \code{sup_ctx}, of degrees
      $m$ and $n$, such that $m$ divides $n$;
    \item an $n\times m$ matrix \code{basis} that maps \code{sub_ctx}
      to an isomorphic subfield in \code{sup_ctx};
    \end{itemize}

    Compute the $m\times n$ matrix of the trace from \code{sup_ctx} to
    \code{sub_ctx}.

    This matrix is computed as
    \[
      \texttt{dual\_to\_mono\_matrix(\_, sub\_ctx)}
      \times \texttt{basis}^t \times
      \texttt{mono\_to\_dual\_matrix(\_, sup\_ctx)}.
    \]
    \textbf{Note:} if
    $m=n$, \code{basis} represents a Frobenius, and the result is its
    inverse matrix.

void fq_get_fmpz_mod_mat(fmpz_mod_mat_t col, const fq_t a, const fq_ctx_t ctx)

    Convert \code{a} to a column vector of length \code{degree(ctx)}.

void fq_set_fmpz_mod_mat(fq_t a, const fmpz_mod_mat_t col, const fq_ctx_t ctx)

    Convert a column vector \code{col} of length \code{degree(ctx)} to
    an element of \code{ctx}.

void fq_composition_matrix(fmpz_mod_mat_t matrix,
                           const fq_t gen, const fq_ctx_t ctx)

    Compute the \emph{composition matrix} of \code{gen}.

    For an element $a\in\mathbf{F}_{p^n}$, its composition matrix is the
    matrix whose columns are $a^0, a^1, \ldots, a^{n-1}$.

void fq_composition_matrix_sub(fmpz_mod_mat_t matrix,
                               const fq_t gen, const fq_ctx_t ctx,
                               slong trunc)

    Compute the \emph{composition matrix} of \code{gen}, truncated to
    \code{trunc} columns.

void fq_mul_matrix(fmpz_mod_mat_t matrix,
                   const fq_t gen, const fq_ctx_t ctx)

    Compute the \emph{multiplication matrix} of \code{gen}.

    For an element $a$ in $\mathbf{F}_{p^n}=\mathbf{F}_p[x]$, its
    multiplication matrix is the matrix whose columns are $a, ax,
    \dots, ax^{n-1}$.

void fq_mono_to_dual_matrix(fmpz_mod_mat_t res, const fq_ctx_t ctx)

    Compute the change of basis matrix from the monomial basis of
    \code{ctx} to its dual basis.

void fq_dual_to_mono_matrix(fmpz_mod_mat_t res, const fq_ctx_t ctx)

    Compute the change of basis matrix from the dual basis of
    \code{ctx} to its monomial basis.

void fq_modulus_pow_series_inv(fmpz_mod_poly_t res,
                               const fq_ctx_t ctx, slong trunc)

    Compute the power series inverse of the reverse of the modulus of
    \code{ctx} up to $O(x^\texttt{trunc})$.

void fq_modulus_derivative_inv(fq_t m_prime, fq_t m_prime_inv,
                               const fq_ctx_t ctx)

    Compute the derivative \code{m_prime} of the modulus of \code{ctx}
    as an element of \code{ctx}, and its inverse \code{m_prime_inv}.
